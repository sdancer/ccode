// Module: D39
// Type: L
// Lines: 482876-484548
//
var createRenderState = L(()=>{
    A2();
});
import { randomUUID as x_ } from "crypto";
function HJ1(A) {
    return (A.type !== "progress" && A.type !== "attachment" && A.type !== "system" && Array.isArray(A.message.content) && A.message.content[0]?.type === "text" && kG0.has(A.message.content[0].text));
}
function m97(A) {
    return (A.type === "assistant" && A.isApiErrorMessage === !0 && A.message.model === YKA);
}
function vDA(A) {
    let Q = A.filter((B)=>B.type === "assistant");
    return wC(Q);
}
function gfA(A) {
    for(let Q = A.length - 1; Q >= 0; Q--){
        let B = A[Q];
        if (B && B.type === "assistant") {
            let Z = B.message.content;
            if (Array.isArray(Z)) return Z.some((Y)=>Y.type === "tool_use");
        }
    }
    return !1;
}
function z39({ content: A, isApiErrorMessage: Q = !1, error: B, usage: G = {
    input_tokens: 0,
    output_tokens: 0,
    cache_creation_input_tokens: 0,
    cache_read_input_tokens: 0,
    server_tool_use: {
        web_search_requests: 0,
        web_fetch_requests: 0
    },
    service_tier: null,
    cache_creation: {
        ephemeral_1h_input_tokens: 0,
        ephemeral_5m_input_tokens: 0
    }
} }) {
    return {
        type: "assistant",
        uuid: x_(),
        timestamp: new Date().toISOString(),
        message: {
            id: x_(),
            container: null,
            model: YKA,
            role: "assistant",
            stop_reason: "stop_sequence",
            stop_sequence: "",
            type: "message",
            usage: G,
            content: A,
            context_management: null
        },
        requestId: void 0,
        error: B,
        isApiErrorMessage: Q
    };
}
function PF({ content: A, usage: Q }) {
    return z39({
        content: typeof A === "string" ? [
            {
                type: "text",
                text: A === "" ? FL : A
            }
        ] : A,
        usage: Q
    });
}
function IX({ content: A, error: Q }) {
    return z39({
        content: [
            {
                type: "text",
                text: A === "" ? FL : A
            }
        ],
        isApiErrorMessage: !0,
        error: Q
    });
}
function h0({ content: A, isMeta: Q, isVisibleInTranscriptOnly: B, isCompactSummary: G, toolUseResult: Z, uuid: Y, thinkingMetadata: J, timestamp: X, todos: I }) {
    return {
        type: "user",
        message: {
            role: "user",
            content: A || FL
        },
        isMeta: Q,
        isVisibleInTranscriptOnly: B,
        isCompactSummary: G,
        uuid: Y ?? x_(),
        timestamp: X ?? new Date().toISOString(),
        toolUseResult: Z,
        thinkingMetadata: J,
        todos: I
    };
}
function w_({ inputString: A, precedingInputBlocks: Q }) {
    if (Q.length === 0) return A;
    return [
        ...Q,
        {
            text: A,
            type: "text"
        }
    ];
}
function BxA({ toolUse: A = !1 }) {
    return h0({
        content: [
            {
                type: "text",
                text: A ? E_ : LDA
            }
        ]
    });
}
function aF() {
    return h0({
        content: "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
        isMeta: !0
    });
}
function iN2({ toolUseID: A, parentToolUseID: Q, data: B }) {
    return {
        type: "progress",
        data: B,
        toolUseID: A,
        parentToolUseID: Q,
        uuid: x_(),
        timestamp: new Date().toISOString()
    };
}
function uH0(A) {
    return {
        type: "tool_result",
        content: AHA,
        is_error: !0,
        tool_use_id: A
    };
}
function Z9(A, Q) {
    if (!A.trim() || !Q.trim()) return null;
    let B = Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), G = new RegExp(`<${B}(?:\\s+[^>]*)?>([\\s\\S]*?)<\\/${B}>`, "gi"), Z, Y = 0, J = 0, X = new RegExp(`<${B}(?:\\s+[^>]*?)?>`, "gi"), I = new RegExp(`<\\/${B}>`, "gi");
    while((Z = G.exec(A)) !== null){
        let W = Z[1], K = A.slice(J, Z.index);
        ((Y = 0), (X.lastIndex = 0));
        while(X.exec(K) !== null)Y++;
        I.lastIndex = 0;
        while(I.exec(K) !== null)Y--;
        if (Y === 0 && W) return W;
        J = Z.index + Z[0].length;
    }
    return null;
}
function BfA(A) {
    if (A.type === "progress" || A.type === "attachment" || A.type === "system") return !0;
    if (typeof A.message.content === "string") return A.message.content.trim().length > 0;
    if (A.message.content.length === 0) return !1;
    if (A.message.content.length > 1) return !0;
    if (A.message.content[0].type !== "text") return !0;
    return (A.message.content[0].text.trim().length > 0 && A.message.content[0].text !== FL && A.message.content[0].text !== E_);
}
function DX(A) {
    let Q = !1;
    return A.flatMap((B)=>{
        switch(B.type){
            case "assistant":
                return ((Q = Q || B.message.content.length > 1), B.message.content.map((G)=>{
                    let Z = Q ? x_() : B.uuid;
                    return {
                        type: "assistant",
                        timestamp: B.timestamp,
                        message: {
                            ...B.message,
                            content: [
                                G
                            ],
                            context_management: B.message.context_management ?? null
                        },
                        isMeta: B.isMeta,
                        requestId: B.requestId,
                        uuid: Z,
                        error: B.error,
                        isApiErrorMessage: B.isApiErrorMessage
                    };
                }));
            case "attachment":
                return [
                    B
                ];
            case "progress":
                return [
                    B
                ];
            case "system":
                return [
                    B
                ];
            case "user":
                {
                    if (typeof B.message.content === "string") {
                        let G = Q ? x_() : B.uuid;
                        return [
                            {
                                ...B,
                                uuid: G,
                                message: {
                                    ...B.message,
                                    content: [
                                        {
                                            type: "text",
                                            text: B.message.content
                                        }
                                    ]
                                }
                            }
                        ];
                    }
                    return ((Q = Q || B.message.content.length > 1), B.message.content.map((G)=>({
                            ...h0({
                                content: [
                                    G
                                ],
                                toolUseResult: B.toolUseResult,
                                isMeta: B.isMeta,
                                isVisibleInTranscriptOnly: B.isVisibleInTranscriptOnly,
                                timestamp: B.timestamp
                            }),
                            uuid: Q ? x_() : B.uuid
                        })));
                }
        }
    });
}
function F39(A) {
    return (A.type === "assistant" && A.message.content.some((Q)=>Q.type === "tool_use"));
}
function QO2(A) {
    return (A.type === "user" && ((Array.isArray(A.message.content) && A.message.content[0]?.type === "tool_result") || Boolean(A.toolUseResult)));
}
function Yq0(A, Q) {
    let B = new Map();
    for (let J of A){
        if (F39(J)) {
            let X = J.message.content[0]?.id;
            if (X) {
                if (!B.has(X)) B.set(X, {
                    toolUse: null,
                    preHooks: [],
                    toolResult: null,
                    postHooks: []
                });
                B.get(X).toolUse = J;
            }
            continue;
        }
        if (aDA(J) && J.attachment.hookEvent === "PreToolUse") {
            let X = J.attachment.toolUseID;
            if (!B.has(X)) B.set(X, {
                toolUse: null,
                preHooks: [],
                toolResult: null,
                postHooks: []
            });
            B.get(X).preHooks.push(J);
            continue;
        }
        if (J.type === "user" && J.message.content[0]?.type === "tool_result") {
            let X = J.message.content[0].tool_use_id;
            if (!B.has(X)) B.set(X, {
                toolUse: null,
                preHooks: [],
                toolResult: null,
                postHooks: []
            });
            B.get(X).toolResult = J;
            continue;
        }
        if (aDA(J) && J.attachment.hookEvent === "PostToolUse") {
            let X = J.attachment.toolUseID;
            if (!B.has(X)) B.set(X, {
                toolUse: null,
                preHooks: [],
                toolResult: null,
                postHooks: []
            });
            B.get(X).postHooks.push(J);
            continue;
        }
    }
    let G = [], Z = new Set();
    for (let J of A){
        if (F39(J)) {
            let X = J.message.content[0]?.id;
            if (X && !Z.has(X)) {
                Z.add(X);
                let I = B.get(X);
                if (I && I.toolUse) {
                    if ((G.push(I.toolUse), G.push(...I.preHooks), I.toolResult)) G.push(I.toolResult);
                    G.push(...I.postHooks);
                }
            }
            continue;
        }
        if (aDA(J) && (J.attachment.hookEvent === "PreToolUse" || J.attachment.hookEvent === "PostToolUse")) continue;
        if (J.type === "user" && J.message.content[0]?.type === "tool_result") continue;
        if (J.type === "system" && J.subtype === "api_error") {
            let X = G.at(-1);
            if (X?.type === "system" && X.subtype === "api_error") G[G.length - 1] = J;
            else G.push(J);
            continue;
        }
        G.push(J);
    }
    for (let J of Q)G.push(J);
    let Y = G.at(-1);
    return G.filter((J)=>J.type !== "system" || J.subtype !== "api_error" || J === Y);
}
function aDA(A) {
    return (A.type === "attachment" && (A.attachment.type === "hook_blocking_error" || A.attachment.type === "hook_cancelled" || A.attachment.type === "hook_error_during_execution" || A.attachment.type === "hook_non_blocking_error" || A.attachment.type === "hook_success" || A.attachment.type === "hook_system_message" || A.attachment.type === "hook_additional_context" || A.attachment.type === "hook_stopped_continuation"));
}
function cn2(A, Q, B) {
    return A.filter((G)=>G.type === "progress" && G.data.type === "hook_progress" && G.data.hookEvent === B && G.parentToolUseID === Q).length;
}
function pn2(A, Q, B) {
    return new Set(A.filter((Z)=>aDA(Z) && Z.attachment.toolUseID === Q && Z.attachment.hookEvent === B).map((Z)=>Z.attachment.hookName)).size;
}
function $V1(A) {
    return Object.fromEntries(A.flatMap((Q)=>Q.type === "user" && Q.message.content[0]?.type === "tool_result" ? [
            [
                Q.message.content[0].tool_use_id,
                Q.message.content[0].is_error ?? !1
            ]
        ] : []));
}
function Ae2(A, Q) {
    let B = new Map(), G = new Map();
    for (let I of Q)if (I.type === "assistant") {
        let W = I.message.id, K = B.get(W);
        if (!K) ((K = new Set()), B.set(W, K));
        for (let V of I.message.content)if (V.type === "tool_use") (K.add(V.id), G.set(V.id, W));
    }
    let Z = new Map();
    for (let [I, W] of G)Z.set(I, B.get(W));
    let Y = new Map(), J = new Map(), X = new Map();
    for (let I of A){
        if (I.type === "progress") {
            let W = I.parentToolUseID, K = Y.get(W);
            if (K) K.push(I);
            else Y.set(W, [
                I
            ]);
            if (I.data.type === "hook_progress") {
                let V = I.data.hookEvent, H = J.get(W);
                if (!H) ((H = new Map()), J.set(W, H));
                H.set(V, (H.get(V) ?? 0) + 1);
            }
        }
        if (aDA(I)) {
            let W = I.attachment.toolUseID, K = I.attachment.hookEvent, V = X.get(W);
            if (!V) ((V = new Map()), X.set(W, V));
            V.set(K, (V.get(K) ?? 0) + 1);
        }
    }
    return {
        siblingToolUseIDs: Z,
        progressMessagesByToolUseID: Y,
        inProgressHookCounts: J,
        resolvedHookCounts: X
    };
}
function Qe2(A, Q) {
    let B = GfA(A);
    if (!B) return new Set();
    return Q.siblingToolUseIDs.get(B) ?? new Set();
}
function Be2(A, Q) {
    let B = GfA(A);
    if (!B) return [];
    return Q.progressMessagesByToolUseID.get(B) ?? [];
}
function Ge2(A, Q, B) {
    let G = B.inProgressHookCounts.get(A)?.get(Q) ?? 0, Z = B.resolvedHookCounts.get(A)?.get(Q) ?? 0;
    return G > Z;
}
function jN0(A) {
    let Q = $V1(A), B = d97(A);
    return Wt2(B, new Set(Object.keys(Q)));
}
function d97(A) {
    return new Set(A.filter((Q)=>Q.type === "assistant" && Array.isArray(Q.message.content) && Q.message.content[0]?.type === "tool_use").map((Q)=>Q.message.content[0].id));
}
function Ze2(A) {
    let Q = $V1(A);
    return new Set(A.filter((B)=>B.type === "assistant" && Array.isArray(B.message.content) && B.message.content[0]?.type === "tool_use" && B.message.content[0]?.id in Q && Q[B.message.content[0]?.id] === !0).map((B)=>B.message.content[0].id));
}
function c97(A) {
    let Q = [], B = [];
    for(let G = A.length - 1; G >= 0; G--){
        let Z = A[G];
        if (Z.type === "attachment") B.unshift(Z);
        else if ((Z.type === "assistant" || (Z.type === "user" && Array.isArray(Z.message.content) && Z.message.content[0]?.type === "tool_result")) && B.length > 0) (Q.unshift(Z, ...B), (B.length = 0));
        else Q.unshift(Z);
    }
    return (Q.unshift(...B), Q);
}
function bS2(A) {
    return A.type === "system" && A.subtype === "local_command";
}
function p97(A, Q) {
    let B = A.message.content;
    if (!Array.isArray(B)) return A;
    if (!B.some((Z)=>Z.type === "tool_result" && Array.isArray(Z.content) && Z.content.some((Y)=>{
            if (!an(Y)) return !1;
            let J = Y.tool_name;
            return J && !Q.has(J);
        }))) return A;
    return {
        ...A,
        message: {
            ...A.message,
            content: B.map((Z)=>{
                if (Z.type !== "tool_result" || !Array.isArray(Z.content)) return Z;
                let Y = Z.content.filter((J)=>{
                    if (!an(J)) return !0;
                    let X = J.tool_name;
                    if (!X) return !0;
                    let I = Q.has(X);
                    if (!I) k(`Filtering out tool_reference for unavailable tool: ${X}`, {
                        level: "warn"
                    });
                    return I;
                });
                if (Y.length === 0) return {
                    ...Z,
                    content: [
                        {
                            type: "text",
                            text: "[Tool references removed - tools no longer available]"
                        }
                    ]
                };
                return {
                    ...Z,
                    content: Y
                };
            })
        }
    };
}
function l97(A) {
    let Q = A.message.content;
    if (!Array.isArray(Q)) return A;
    if (!Q.some((G)=>G.type === "tool_result" && Array.isArray(G.content) && G.content.some(an))) return A;
    return {
        ...A,
        message: {
            ...A.message,
            content: Q.map((G)=>{
                if (G.type !== "tool_result" || !Array.isArray(G.content)) return G;
                let Z = G.content.filter((Y)=>!an(Y));
                if (Z.length === 0) return {
                    ...G,
                    content: [
                        {
                            type: "text",
                            text: "[Tool references removed - tool search not enabled]"
                        }
                    ]
                };
                return {
                    ...G,
                    content: Z
                };
            })
        }
    };
}
function EJ(A, Q = []) {
    let B = new Set(Q.map((Y)=>Y.name)), G = c97(A), Z = [];
    return (G.filter((Y)=>{
        if (Y.type === "progress" || Y.type === "system" || m97(Y)) return !1;
        return !0;
    }).forEach((Y)=>{
        switch(Y.type){
            case "user":
                {
                    let J = Y;
                    if (!fv()) J = l97(Y);
                    else J = p97(Y, B);
                    let X = wC(Z);
                    if (X?.type === "user") {
                        Z[Z.indexOf(X)] = o97(X, J);
                        return;
                    }
                    Z.push(J);
                    return;
                }
            case "assistant":
                {
                    let J = fv(), X = {
                        ...Y,
                        message: {
                            ...Y.message,
                            content: Y.message.content.map((I)=>{
                                if (I.type === "tool_use") {
                                    let W = Q.find((V)=>V.name === I.name), K = W ? UN2(W, I.input) : I.input;
                                    if (J) return {
                                        ...I,
                                        input: K
                                    };
                                    return {
                                        type: "tool_use",
                                        id: I.id,
                                        name: I.name,
                                        input: K
                                    };
                                }
                                return I;
                            })
                        }
                    };
                    for(let I = Z.length - 1; I >= 0; I--){
                        let W = Z[I];
                        if (W.type !== "assistant" && !a97(W)) break;
                        if (W.type === "assistant") {
                            if (W.message.id === X.message.id) {
                                Z[I] = n97(W, X);
                                return;
                            }
                            break;
                        }
                    }
                    Z.push(X);
                    return;
                }
            case "attachment":
                {
                    let J = Q47(Y.attachment), X = wC(Z);
                    if (X?.type === "user") {
                        Z[Z.indexOf(X)] = J.reduce((I, W)=>i97(I, W), X);
                        return;
                    }
                    Z.push(...J);
                    return;
                }
        }
    }), G47(Z));
}
function i97(A, Q) {
    let B = SH1(A.message.content), G = SH1(Q.message.content);
    return {
        ...A,
        message: {
            ...A.message,
            content: C39(r97(B, G))
        }
    };
}
function n97(A, Q) {
    return {
        ...A,
        message: {
            ...A.message,
            content: [
                ...A.message.content,
                ...Q.message.content
            ]
        }
    };
}
function a97(A) {
    if (A.type !== "user") return !1;
    let Q = A.message.content;
    if (typeof Q === "string") return !1;
    return Q.some((B)=>B.type === "tool_result");
}
function o97(A, Q) {
    let B = SH1(A.message.content), G = SH1(Q.message.content);
    return {
        ...A,
        message: {
            ...A.message,
            content: C39([
                ...B,
                ...G
            ])
        }
    };
}
function C39(A) {
    let Q = [], B = [];
    for (let G of A)if (G.type === "tool_result") Q.push(G);
    else B.push(G);
    return [
        ...Q,
        ...B
    ];
}
function SH1(A) {
    if (typeof A === "string") return [
        {
            type: "text",
            text: A
        }
    ];
    return A;
}
function r97(A, Q) {
    let B = wC(A);
    if (B?.type === "tool_result" && typeof B.content === "string" && Q.every((G)=>G.type === "text")) return [
        ...A.slice(0, -1),
        {
            ...B,
            content: [
                B.content,
                ...Q.map((G)=>G.text)
            ].map((G)=>G.trim()).filter(Boolean).join(`

`)
        }
    ];
    return [
        ...A,
        ...Q
    ];
}
function nN0(A, Q, B) {
    if (!A) return [];
    return A.map((G)=>{
        switch(G.type){
            case "tool_use":
                {
                    if (typeof G.input !== "string" && !LX(G.input)) throw Error("Tool use input must be a string or object");
                    let Z = typeof G.input === "string" ? (_5(G.input) ?? {}) : G.input;
                    if (typeof Z === "object" && Z !== null) {
                        let Y = Q.find((J)=>J.name === G.name);
                        if (Y) try {
                            Z = $N2(Y, Z, B);
                        } catch (J) {
                            t(Error("Error normalizing tool input: " + J));
                        }
                    }
                    return {
                        ...G,
                        input: Z
                    };
                }
            case "text":
                if (G.text.trim().length === 0) return (r("tengu_empty_model_response", {}), {
                    type: "text",
                    text: FL
                });
                return G;
            case "code_execution_tool_result":
            case "mcp_tool_use":
            case "mcp_tool_result":
            case "container_upload":
            case "server_tool_use":
                return G;
            default:
                return G;
        }
    });
}
function DJ1(A) {
    return FxA(A).trim() === "" || A.trim() === FL;
}
function FxA(A) {
    let Q = new RegExp(`<(${s97.join("|")})>.*?</\\1>
?`, "gs");
    return A.replace(Q, "").trim();
}
function GfA(A) {
    switch(A.type){
        case "attachment":
            if (aDA(A)) return A.attachment.toolUseID;
            return null;
        case "assistant":
            if (A.message.content[0]?.type !== "tool_use") return null;
            return A.message.content[0].id;
        case "user":
            if (A.sourceToolUseID) return A.sourceToolUseID;
            if (A.message.content[0]?.type !== "tool_result") return null;
            return A.message.content[0].tool_use_id;
        case "progress":
            return A.toolUseID;
        case "system":
            return A.subtype === "informational" ? (A.toolUseID ?? null) : null;
    }
}
function LB2(A) {
    let Q = DX(A), B = jN0(Q);
    return Q.filter((Z, Y)=>{
        if (Z.type === "assistant" && Z.message.content[0]?.type === "tool_use" && B.has(Z.message.content[0].id)) return !1;
        return !0;
    });
}
function Q9A(A) {
    if (A.type !== "assistant") return null;
    if (Array.isArray(A.message.content)) return (A.message.content.filter((Q)=>Q.type === "text").map((Q)=>(Q.type === "text" ? Q.text : "")).join(`
`).trim() || null);
    return null;
}
function c49(A) {
    if (A.type !== "user") return null;
    let Q = A.message.content;
    return w4A(Q);
}
function w4A(A) {
    if (typeof A === "string") return A;
    if (Array.isArray(A)) return (A.filter((Q)=>Q.type === "text").map((Q)=>(Q.type === "text" ? Q.text : "")).join(`
`).trim() || null);
    return null;
}
function k4A(A, Q, B, G, Z, Y) {
    if (A.type !== "stream_event" && A.type !== "stream_request_start") {
        if (A.type === "tombstone") {
            Y?.(A.message);
            return;
        }
        Q(A);
        return;
    }
    if (A.type === "stream_request_start") {
        G("requesting");
        return;
    }
    if (A.event.type === "message_stop") {
        (G("tool-use"), Z(()=>[]));
        return;
    }
    switch(A.event.type){
        case "content_block_start":
            switch(A.event.content_block.type){
                case "thinking":
                case "redacted_thinking":
                    G("thinking");
                    return;
                case "text":
                    G("responding");
                    return;
                case "tool_use":
                    {
                        G("tool-input");
                        let J = A.event.content_block, X = A.event.index;
                        Z((I)=>[
                                ...I,
                                {
                                    index: X,
                                    contentBlock: J,
                                    unparsedToolInput: ""
                                }
                            ]);
                        return;
                    }
                case "server_tool_use":
                case "web_search_tool_result":
                case "code_execution_tool_result":
                case "mcp_tool_use":
                case "mcp_tool_result":
                case "container_upload":
                case "web_fetch_tool_result":
                case "bash_code_execution_tool_result":
                case "text_editor_code_execution_tool_result":
                    G("tool-input");
                    return;
            }
            break;
        case "content_block_delta":
            switch(A.event.delta.type){
                case "text_delta":
                    B(A.event.delta.text);
                    return;
                case "input_json_delta":
                    {
                        let J = A.event.delta.partial_json, X = A.event.index;
                        (B(J), Z((I)=>{
                            let W = I.find((K)=>K.index === X);
                            if (!W) return I;
                            return [
                                ...I.filter((K)=>K !== W),
                                {
                                    ...W,
                                    unparsedToolInput: W.unparsedToolInput + J
                                }
                            ];
                        }));
                        return;
                    }
                case "thinking_delta":
                    B(A.event.delta.thinking);
                    return;
                case "signature_delta":
                    B(A.event.delta.signature);
                    return;
                default:
                    return;
            }
        case "message_delta":
            G("responding");
            return;
        default:
            G("responding");
            return;
    }
}
function lf(A) {
    return `<system-reminder>
${A}
</system-reminder>`;
}
function p7(A) {
    return A.map((Q)=>{
        if (typeof Q.message.content === "string") return {
            ...Q,
            message: {
                ...Q.message,
                content: lf(Q.message.content)
            }
        };
        else if (Array.isArray(Q.message.content)) {
            let B = Q.message.content.map((G)=>{
                if (G.type === "text") return {
                    ...G,
                    text: lf(G.text)
                };
                return G;
            });
            return {
                ...Q,
                message: {
                    ...Q.message,
                    content: B
                }
            };
        }
        return Q;
    });
}
function t97(A) {
    if (A.isSubAgent) return A47(A);
    return e97(A);
}
function e97(A) {
    if (A.isSubAgent) return [];
    let Q = V39(), B = H39(), Z = `Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits (with the exception of the plan file mentioned below), run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received.

## Plan File Info:
${A.planExists ? `A plan file already exists at ${A.planFilePath}. You can read it and make incremental edits using the ${Fz.name} tool.` : `No plan file exists yet. You should create your plan at ${A.planFilePath} using the ${yV.name} tool.`}
You should build your plan incrementally by writing to or editing this file. NOTE that this is the only file you are allowed to edit - other than this you are only allowed to take READ-ONLY actions.

## Plan Workflow

### Phase 1: Initial Understanding
Goal: Gain a comprehensive understanding of the user's request by reading through code and asking them questions. Critical: In this phase you should only use the ${xL.agentType} subagent type.

1. Focus on understanding the user's request and the code associated with their request

2. **Launch up to ${B} ${xL.agentType} agents IN PARALLEL** (single message, multiple tool calls) to efficiently explore the codebase.
   - Use 1 agent when the task is isolated to known files, the user provided specific file paths, or you're making a small targeted change.
   - Use multiple agents when: the scope is uncertain, multiple areas of the codebase are involved, or you need to understand existing patterns before planning.
   - Quality over quantity - ${B} agents maximum, but you should try to use the minimum number of agents necessary (usually just 1)
   - If using multiple agents: Provide each agent with a specific search focus or area to explore. Example: One agent searches for existing implementations, another explores related components, a third investigates testing patterns

3. After exploring the code, use the ${yI} tool to clarify ambiguities in the user request up front.

### Phase 2: Design
Goal: Design an implementation approach.

Launch ${rVA.agentType} agent(s) to design the implementation based on the user's intent and your exploration results from Phase 1.

You can launch up to ${Q} agent(s) in parallel.

**Guidelines:**
- **Default**: Launch at least 1 Plan agent for most tasks - it helps validate your understanding and consider alternatives
- **Skip agents**: Only for truly trivial tasks (typo fixes, single-line changes, simple renames)
${Q > 1 ? `- **Multiple agents**: Use up to ${Q} agents for complex tasks that benefit from different perspectives

Examples of when to use multiple agents:
- The task touches multiple parts of the codebase
- It's a large refactor or architectural change
- There are many edge cases to consider
- You'd benefit from exploring different approaches

Example perspectives by task type:
- New feature: simplicity vs performance vs maintainability
- Bug fix: root cause vs workaround vs prevention
- Refactoring: minimal change vs clean architecture
` : ""}
In the agent prompt:
- Provide comprehensive background context from Phase 1 exploration including filenames and code path traces
- Describe requirements and constraints
- Request a detailed implementation plan

### Phase 3: Review
Goal: Review the plan(s) from Phase 2 and ensure alignment with the user's intentions.
1. Read the critical files identified by agents to deepen your understanding
2. Ensure that the plans align with the user's original request
3. Use ${yI} to clarify any remaining questions with the user

### Phase 4: Final Plan
Goal: Write your final plan to the plan file (the only file you can edit).
- Include only your recommended approach, not all alternatives
- Ensure that the plan file is concise enough to scan quickly, but detailed enough to execute effectively
- Include the paths of critical files to be modified

### Phase 5: Call ${uL.name}
At the very end of your turn, once you have asked the user questions and are happy with your final plan file - you should always call ${uL.name} to indicate to the user that you are done planning.
This is critical - your turn should only end with either asking the user a question or calling ${uL.name}. Do not stop unless it's for these 2 reasons.

NOTE: At any point in time through this workflow you should feel free to ask the user questions or clarifications. Don't make large assumptions about user intent. The goal is to present a well researched plan to the user, and tie any loose ends before implementation begins.`;
    return p7([
        h0({
            content: Z,
            isMeta: !0
        })
    ]);
}
function A47(A) {
    let B = `Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received (for example, to make edits). Instead, you should:

## Plan File Info:
${A.planExists ? `A plan file already exists at ${A.planFilePath}. You can read it and make incremental edits using the ${Fz.name} tool if you need to.` : `No plan file exists yet. You should create your plan at ${A.planFilePath} using the ${yV.name} tool if you need to.`}
You should build your plan incrementally by writing to or editing this file. NOTE that this is the only file you are allowed to edit - other than this you are only allowed to take READ-ONLY actions.
Answer the user's query comprehensively, using the ${yI} tool if you need to ask the user clarifying questions. If you do use the ${yI}, make sure to ask all clarifying questions you need to fully understand the user's intent before proceeding.`;
    return p7([
        h0({
            content: B,
            isMeta: !0
        })
    ]);
}
function Q47(A) {
    switch(A.type){
        case "directory":
            return p7([
                hfA(M9.name, {
                    command: `ls ${i6([
                        A.path
                    ])}`,
                    description: `Lists files in ${A.path}`
                }),
                bfA(M9, {
                    stdout: A.content,
                    stderr: "",
                    interrupted: !1
                })
            ]);
        case "edited_text_file":
            return p7([
                h0({
                    content: `Note: ${A.filename} was modified, either by the user or by a linter. This change was intentional, so make sure to take it into account as you proceed (ie. don't revert it unless the user asks you to). Don't tell the user this, since they are already aware. Here are the relevant changes (shown with line numbers):
${A.snippet}`,
                    isMeta: !0
                })
            ]);
        case "file":
            {
                let B = A.content;
                switch(B.type){
                    case "image":
                        return p7([
                            hfA(D3.name, {
                                file_path: A.filename
                            }),
                            bfA(D3, B)
                        ]);
                    case "text":
                        return p7([
                            hfA(D3.name, {
                                file_path: A.filename
                            }),
                            bfA(D3, B),
                            ...(A.truncated ? [
                                h0({
                                    content: `Note: The file ${A.filename} was too large and has been truncated to the first ${hNA} lines. Don't tell the user about this truncation. Use ${D3.name} to read more of the file if you need.`,
                                    isMeta: !0
                                })
                            ] : [])
                        ]);
                    case "notebook":
                        return p7([
                            hfA(D3.name, {
                                file_path: A.filename
                            }),
                            bfA(D3, B)
                        ]);
                    case "pdf":
                        return p7([
                            hfA(D3.name, {
                                file_path: A.filename
                            }),
                            bfA(D3, B)
                        ]);
                }
                break;
            }
        case "compact_file_reference":
            return p7([
                h0({
                    content: `Note: ${A.filename} was read before the last conversation was summarized, but the contents are too large to include. Use ${D3.name} tool if you need to access it.`,
                    isMeta: !0
                })
            ]);
        case "selected_lines_in_ide":
            {
                let G = A.content.length > 2000 ? A.content.substring(0, 2000) + `
... (truncated)` : A.content;
                return p7([
                    h0({
                        content: `The user selected the lines ${A.lineStart} to ${A.lineEnd} from ${A.filename}:
${G}

This may or may not be related to the current task.`,
                        isMeta: !0
                    })
                ]);
            }
        case "opened_file_in_ide":
            return p7([
                h0({
                    content: `The user opened the file ${A.filename} in the IDE. This may or may not be related to the current task.`,
                    isMeta: !0
                })
            ]);
        case "todo":
            if (A.itemCount === 0) return p7([
                h0({
                    content: `This is a reminder that your todo list is currently empty. DO NOT mention this to the user explicitly because they are already aware. If you are working on tasks that would benefit from a todo list please use the ${fX.name} tool to create one. If not, please feel free to ignore. Again do not mention this message to the user.`,
                    isMeta: !0
                })
            ]);
            else return p7([
                h0({
                    content: `Your todo list has changed. DO NOT mention this explicitly to the user. Here are the latest contents of your todo list:

${JSON.stringify(A.content)}. Continue on with the tasks at hand if applicable.`,
                    isMeta: !0
                })
            ]);
        case "plan_file_reference":
            return p7([
                h0({
                    content: `A plan file exists from plan mode at: ${A.planFilePath}

Plan contents:

${A.planContent}

If this plan is relevant to the current work and not already complete, continue working on it.`,
                    isMeta: !0
                })
            ]);
        case "invoked_skills":
            {
                if (A.skills.length === 0) return [];
                let B = A.skills.map((G)=>`### Skill: ${G.name}
Path: ${G.path}

${G.content}`).join(`

---

`);
                return p7([
                    h0({
                        content: `The following skills were invoked in this session. Continue to follow these guidelines:

${B}`,
                        isMeta: !0
                    })
                ]);
            }
        case "todo_reminder":
            {
                let B = A.content.map((Z, Y)=>`${Y + 1}. [${Z.status}] ${Z.content}`).join(`
`), G = `The TodoWrite tool hasn't been used recently. If you're working on tasks that would benefit from tracking progress, consider using the TodoWrite tool to track progress. Also consider cleaning up the todo list if has become stale and no longer matches what you are working on. Only use it if it's relevant to the current work. This is just a gentle reminder - ignore if not applicable. Make sure that you NEVER mention this reminder to the user
`;
                if (B.length > 0) G += `

Here are the existing contents of your todo list:

[${B}]`;
                return p7([
                    h0({
                        content: G,
                        isMeta: !0
                    })
                ]);
            }
        case "nested_memory":
            return p7([
                h0({
                    content: `Contents of ${A.content.path}:

${A.content.content}`,
                    isMeta: !0
                })
            ]);
        case "queued_command":
            {
                let B = Array.isArray(A.prompt) ? A.prompt.map((G)=>(G.type === "text" ? G.text : "")).join(`
`) : A.prompt;
                return p7([
                    h0({
                        content: `The user sent the following message:
${B}

Please address this message and continue with your tasks.`,
                        isMeta: !0
                    })
                ]);
            }
        case "ultramemory":
            return p7([
                h0({
                    content: A.content,
                    isMeta: !0
                })
            ]);
        case "output_style":
            {
                let B = M4A[A.style];
                if (!B) return [];
                return p7([
                    h0({
                        content: `${B.name} output style is active. Remember to follow the specific guidelines for this style.`,
                        isMeta: !0
                    })
                ]);
            }
        case "diagnostics":
            {
                if (A.files.length === 0) return [];
                let B = RP.formatDiagnosticsSummary(A.files);
                return p7([
                    h0({
                        content: `<new-diagnostics>The following new diagnostic issues were detected:

${B}</new-diagnostics>`,
                        isMeta: !0
                    })
                ]);
            }
        case "plan_mode":
            return t97(A);
        case "plan_mode_reentry":
            {
                let B = `## Re-entering Plan Mode

You are returning to plan mode after having previously exited it. A plan file exists at ${A.planFilePath} from your previous planning session.

**Before proceeding with any new planning, you should:**
1. Read the existing plan file to understand what was previously planned
2. Evaluate the user's current request against that plan
3. Decide how to proceed:
   - **Different task**: If the user's request is for a different task—even if it's similar or related—start fresh by overwriting the existing plan
   - **Same task, continuing**: If this is explicitly a continuation or refinement of the exact same task, modify the existing plan while cleaning up outdated or irrelevant sections
4. Continue on with the plan process and most importantly you should always edit the plan file one way or the other before calling ${uL.name}

Treat this as a fresh planning session. Do not assume the existing plan is relevant without evaluating it first.`;
                return p7([
                    h0({
                        content: B,
                        isMeta: !0
                    })
                ]);
            }
        case "plan_mode_exit":
            {
                let G = `## Exited Plan Mode

You have exited plan mode. You can now make edits, run tools, and take actions.${A.planExists ? ` The plan file is located at ${A.planFilePath} if you need to reference it.` : ""}`;
                return p7([
                    h0({
                        content: G,
                        isMeta: !0
                    })
                ]);
            }
        case "delegate_mode":
            {
                let B = `## Delegate Mode

You are in delegate mode for team "${A.teamName}". In this mode, you can ONLY use the following tools:
- TeammateTool: For spawning teammates, sending messages, and team coordination
- TaskCreate: For creating new tasks
- TaskGet: For retrieving task details
- TaskUpdate: For updating task status and adding comments
- TaskList: For listing all tasks

You CANNOT use any other tools (Bash, Read, Write, Edit, etc.) until you exit delegate mode.

**Task list location:** ${A.taskListPath}

Focus on coordinating work by creating tasks, assigning them to teammates, and monitoring progress. Use the Teammate tool to communicate with your team.`;
                return p7([
                    h0({
                        content: B,
                        isMeta: !0
                    })
                ]);
            }
        case "delegate_mode_exit":
            return p7([
                h0({
                    content: `## Exited Delegate Mode

You have exited delegate mode. You can now use all tools (Bash, Read, Write, Edit, etc.) and take actions directly. Continue with your tasks.`,
                    isMeta: !0
                })
            ]);
        case "critical_system_reminder":
            return p7([
                h0({
                    content: A.content,
                    isMeta: !0
                })
            ]);
        case "mcp_resource":
            {
                let B = A.content;
                if (!B || !B.contents || B.contents.length === 0) return p7([
                    h0({
                        content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No content)</mcp-resource>`,
                        isMeta: !0
                    })
                ]);
                let G = [];
                for (let Z of B.contents)if (Z && typeof Z === "object") {
                    if ("text" in Z && typeof Z.text === "string") G.push({
                        type: "text",
                        text: "Full contents of resource:"
                    }, {
                        type: "text",
                        text: Z.text
                    }, {
                        type: "text",
                        text: "Do NOT read this resource again unless you think it may have changed, since you already have the full contents."
                    });
                    else if ("blob" in Z) {
                        let Y = "mimeType" in Z ? String(Z.mimeType) : "application/octet-stream";
                        G.push({
                            type: "text",
                            text: `[Binary content: ${Y}]`
                        });
                    }
                }
                if (G.length > 0) return p7([
                    h0({
                        content: G,
                        isMeta: !0
                    })
                ]);
                else return (s0(A.server, `No displayable content found in MCP resource ${A.uri}.`), p7([
                    h0({
                        content: `<mcp-resource server="${A.server}" uri="${A.uri}">(No displayable content)</mcp-resource>`,
                        isMeta: !0
                    })
                ]));
            }
        case "agent_mention":
            return p7([
                h0({
                    content: `The user has expressed a desire to invoke the agent "${A.agentType}". Please invoke the agent appropriately, passing in the required context to it. `,
                    isMeta: !0
                })
            ]);
        case "task_status":
            {
                let B = [
                    `Task ${A.taskId}`,
                    `(type: ${A.taskType})`,
                    `(status: ${A.status})`,
                    `(description: ${A.description})`
                ];
                if (A.deltaSummary) B.push(`Delta: ${A.deltaSummary}`);
                return (B.push("You can check its output using the TaskOutput tool."), [
                    h0({
                        content: lf(B.join(" ")),
                        isMeta: !0
                    })
                ]);
            }
        case "task_progress":
            return [
                h0({
                    content: lf(A.message),
                    isMeta: !0
                })
            ];
        case "async_hook_response":
            {
                let B = A.response, G = [];
                if (B.systemMessage) G.push(h0({
                    content: B.systemMessage,
                    isMeta: !0
                }));
                if (B.hookSpecificOutput && "additionalContext" in B.hookSpecificOutput && B.hookSpecificOutput.additionalContext) G.push(h0({
                    content: B.hookSpecificOutput.additionalContext,
                    isMeta: !0
                }));
                return p7(G);
            }
        case "teammate_mailbox":
            return [
                h0({
                    content: QC2(A.messages),
                    isMeta: !0
                })
            ];
        case "team_context":
            return [
                h0({
                    content: `<system-reminder>
# Team Coordination

You are a teammate in team "${A.teamName}".

**Your Identity:**
- Name: ${A.agentName}

**Team Resources:**
- Team config: ${A.teamConfigPath}
- Task list: ${A.taskListPath}

**Team Leader:** The team lead's name is "team-lead". Send updates and completion notifications to them.

Read the team config to discover your teammates' names. Check the task list periodically. Create new tasks when work should be divided. Mark tasks resolved when complete.

**IMPORTANT:** Always refer to teammates by their NAME (e.g., "team-lead", "analyzer", "researcher"), never by UUID. When messaging, use the name directly:

\`\`\`json
{
  "operation": "write",
  "target_agent_id": "team-lead",
  "value": "Your message here"
}
\`\`\`
</system-reminder>`,
                    isMeta: !0
                })
            ];
        case "memory":
            {
                let B = A.memories.map((G)=>{
                    let Z = G.remainingLines && G.remainingLines > 0 ? ` (${G.remainingLines} more lines in full file)` : "";
                    return `## Previous Session (${(G.lastModified instanceof Date ? G.lastModified : new Date(G.lastModified)).toLocaleDateString()})
Full session notes: ${G.fullPath}${Z}

${G.content}`;
                }).join(`

---

`);
                return p7([
                    h0({
                        content: `<session-memory>
These session summaries are from PAST sessions that might not be related to the current task and may have outdated info. Do not assume the current task is related to these summaries, until the user's messages indicate so or reference similar tasks. Only a preview of each memory is shown - use the Read tool with the provided path to access full session memory when a session is relevant.

${B}
</session-memory>`,
                        isMeta: !0
                    })
                ]);
            }
        case "token_usage":
            return [
                h0({
                    content: lf(`Token usage: ${A.used}/${A.total}; ${A.remaining} remaining`),
                    isMeta: !0
                })
            ];
        case "budget_usd":
            return [
                h0({
                    content: lf(`USD budget: $${A.used}/$${A.total}; $${A.remaining} remaining`),
                    isMeta: !0
                })
            ];
        case "hook_blocking_error":
            return [
                h0({
                    content: lf(`${A.hookName} hook blocking error from command: "${A.blockingError.command}": ${A.blockingError.blockingError}`),
                    isMeta: !0
                })
            ];
        case "hook_success":
            if (A.hookEvent !== "SessionStart" && A.hookEvent !== "UserPromptSubmit") return [];
            if (A.content === "") return [];
            return [
                h0({
                    content: lf(`${A.hookName} hook success: ${A.content}`),
                    isMeta: !0
                })
            ];
        case "hook_additional_context":
            {
                if (A.content.length === 0) return [];
                return [
                    h0({
                        content: lf(`${A.hookName} hook additional context: ${A.content.join(`
`)}`),
                        isMeta: !0
                    })
                ];
            }
        case "hook_stopped_continuation":
            return [
                h0({
                    content: lf(`${A.hookName} hook stopped continuation: ${A.message}`),
                    isMeta: !0
                })
            ];
        case "already_read_file":
        case "command_permissions":
        case "edited_image_file":
        case "hook_cancelled":
        case "hook_error_during_execution":
        case "hook_non_blocking_error":
        case "hook_system_message":
        case "structured_output":
        case "hook_permission_decision":
            return [];
    }
    if ([
        "autocheckpointing",
        "background_task_status"
    ].includes(A.type)) return [];
    return (bO("normalizeAttachmentForAPI", Error(`Unknown attachment type: ${A.type}`)), []);
}
function bfA(A, Q) {
    try {
        let B = A.mapToolResultToToolResultBlockParam(Q, "1");
        if (Array.isArray(B.content) && B.content.some((G)=>G.type === "image")) return h0({
            content: B.content,
            isMeta: !0
        });
        return h0({
            content: `Result of calling the ${A.name} tool: ${JSON.stringify(B.content)}`,
            isMeta: !0
        });
    } catch  {
        return h0({
            content: `Result of calling the ${A.name} tool: Error`,
            isMeta: !0
        });
    }
}
function hfA(A, Q) {
    return h0({
        content: `Called the ${A} tool with the following input: ${JSON.stringify(Q)}`,
        isMeta: !0
    });
}
function eP(A, Q, B, G) {
    return {
        type: "system",
        subtype: "informational",
        content: A,
        isMeta: !1,
        timestamp: new Date().toISOString(),
        uuid: x_(),
        toolUseID: B,
        level: Q,
        ...(G && {
            preventContinuation: G
        })
    };
}
function nN2(A, Q, B, G, Z, Y, J, X) {
    return {
        type: "system",
        subtype: "stop_hook_summary",
        hookCount: A,
        hookInfos: Q,
        hookErrors: B,
        preventedContinuation: G,
        stopReason: Z,
        hasOutput: Y,
        level: J,
        timestamp: new Date().toISOString(),
        uuid: x_(),
        toolUseID: X
    };
}
function oE0(A) {
    return {
        type: "system",
        subtype: "local_command",
        content: A,
        level: "info",
        timestamp: new Date().toISOString(),
        uuid: x_(),
        isMeta: !1
    };
}
function pZ1(A, Q) {
    return {
        type: "system",
        subtype: "compact_boundary",
        content: "Conversation compacted",
        isMeta: !1,
        timestamp: new Date().toISOString(),
        uuid: x_(),
        level: "info",
        compactMetadata: {
            trigger: A,
            preTokens: Q
        }
    };
}
function vQ2(A, Q, B, G) {
    return {
        type: "system",
        subtype: "api_error",
        level: "error",
        cause: A.cause instanceof Error ? A.cause : void 0,
        error: A,
        retryInMs: Q,
        retryAttempt: B,
        maxRetries: G,
        timestamp: new Date().toISOString(),
        uuid: x_()
    };
}
function ru(A) {
    return A?.type === "system" && A.subtype === "compact_boundary";
}
function B47(A) {
    for(let Q = A.length - 1; Q >= 0; Q--){
        let B = A[Q];
        if (B && ru(B)) return Q;
    }
    return -1;
}
function QS(A) {
    let Q = B47(A);
    if (Q === -1) return A;
    return A.slice(Q);
}
function Jq0(A, Q) {
    if (A.type !== "user") return !0;
    if (A.isMeta) return !1;
    if (A.isVisibleInTranscriptOnly && !Q) return !1;
    return !0;
}
function dZ1(A) {
    if (A.type !== "assistant") return !1;
    if (!Array.isArray(A.message.content)) return !1;
    return A.message.content.every((Q)=>Q.type === "thinking");
}
function Tq0(A, Q, B) {
    let G = 0;
    for (let Z of A){
        if (!Z) continue;
        if (Z.type === "assistant" && Array.isArray(Z.message.content)) {
            if (Z.message.content.some((J)=>J.type === "tool_use" && J.name === Q)) {
                if ((G++, B && G >= B)) return G;
            }
        }
    }
    return G;
}
function wS2(A, Q) {
    let B;
    for(let G = A.length - 1; G >= 0; G--){
        let Z = A[G];
        if (!Z) continue;
        if (Z.type === "assistant" && Array.isArray(Z.message.content)) {
            let Y = Z.message.content.find((J)=>J.type === "tool_use" && J.name === Q);
            if (Y) {
                B = Y.id;
                break;
            }
        }
    }
    if (!B) return !1;
    for(let G = A.length - 1; G >= 0; G--){
        let Z = A[G];
        if (!Z) continue;
        if (Z.type === "user" && Array.isArray(Z.message.content)) {
            let Y = Z.message.content.find((J)=>J.type === "tool_result" && J.tool_use_id === B);
            if (Y) return Y.is_error !== !0;
        }
    }
    return !1;
}
function E39(A) {
    return A.type === "thinking" || A.type === "redacted_thinking";
}
function G47(A) {
    let Q = A[A.length - 1];
    if (!Q || Q.type !== "assistant") return A;
    let B = Q.message.content, G = B[B.length - 1];
    if (!G || !E39(G)) return A;
    let Z = B.length - 1;
    while(Z >= 0){
        let X = B[Z];
        if (!X || !E39(X)) break;
        Z--;
    }
    r("tengu_filtered_trailing_thinking_block", {
        messageUUID: Q.uuid,
        blocksRemoved: B.length - Z - 1,
        remainingBlocks: Z + 1
    });
    let Y = Z < 0 ? [
        {
            type: "text",
            text: "[No message content]",
            citations: []
        }
    ] : B.slice(0, Z + 1), J = [
        ...A
    ];
    return ((J[A.length - 1] = {
        ...Q,
        message: {
            ...Q.message,
            content: Y
        }
    }), J);
}
var LDA = "[Request interrupted by user]", E_ = "[Request interrupted by user for tool use]", AHA = "The user doesn't want to take this action right now. STOP what you are doing and wait for the user to tell you how to proceed.", K9A = "The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.", ykA = `The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:
`, Aw0 = `The agent proposed a plan that was rejected by the user. The user chose to stay in plan mode rather than proceed with implementation.

Rejected plan:
`, W2A = "No response requested.", YKA = "<synthetic>", kG0, s97;
